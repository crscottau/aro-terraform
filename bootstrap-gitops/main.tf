provider kubernetes {
  config_path = "../cluster/kubeconfig" # Will not accept a variable, hopefully ADO allows passing files between steps
}

# Disable the default catalog sources, this needs to be done as a patch as the Terraform kKebernetes provider
# does not like updating existing resources.  Also means the destroy doesn't really work.
resource "null_resource" "disable_catalog_sources" {
  provisioner "local-exec" {
    command = "oc --kubeconfig=${var.kubeconfig} patch OperatorHub cluster --type json -p '[{\"op\": \"add\", \"path\": \"/spec/disableAllDefaultSources\", \"value\": true}]'" 
  }

}

# Create the ImageContentSourcePolicy resources. These are as generated by the "oc mirror" plugin, but the 
# generated content needs to be split into 2 files as the Kubernetes provider wil nto accept multiple
# resources in the 1 file.
resource "kubernetes_manifest" "imagecontentsourcepolicy1" {
  manifest = yamldecode(file("imageContentSourcePolicy1.yaml"))
}

resource "kubernetes_manifest" "imagecontentsourcepolicy2" {
  manifest = yamldecode(file("imageContentSourcePolicy2.yaml"))
}

# Create the CatalogSource resource. These is as generated by the "oc mirror" plugin
resource "kubernetes_manifest" "cataloguesource" {
  manifest = yamldecode(file("catalogSource-cs-redhat-operator-index.yaml"))
}

# Create the ClusterRoleBinding for ServiceAccounts to ClusterAdmin
resource "kubernetes_manifest" "openshift-gitops-cluster-admin" {
  manifest = yamldecode(<<EOT
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: openshift-gitops-cluster-admin
subjects:
  - kind: ServiceAccount
    name: openshift-gitops-argocd-application-controller
    namespace: openshift-gitops
  - kind: ServiceAccount
    name: openshift-gitops-applicationset-controller
    namespace: openshift-gitops
  - kind: ServiceAccount
    name: openshift-gitops-argocd-server
    namespace: openshift-gitops
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
EOT
  )
}

# Create the subscription for the OpenShift GitOps operator
# Wait for the CSV to be installed
resource "kubernetes_manifest" "gitops_subscription" {
  manifest = yamldecode(<<EOT
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: openshift-gitops-operator
  namespace: openshift-operators
spec:
  channel: latest
  installPlanApproval: Automatic
  name: openshift-gitops-operator
  source: ${var.catalogue_name}
  sourceNamespace: openshift-marketplace
EOT
  )

  wait {
    fields = {
      "status.installedCSV" = "^openshift-gitops-operator.+"
    }
  }

  timeouts {
    create = "5m"
    update = "5m"
    delete = "30s"
  }

  depends_on = [ null_resource.disable_catalog_sources, kubernetes_manifest.cataloguesource, kubernetes_manifest.imagecontentsourcepolicy1, kubernetes_manifest.imagecontentsourcepolicy2 ] 
  #depends_on = [ kubernetes_manifest.cataloguesource, kubernetes_manifest.imagecontentsourcepolicy ] 

}

# The GitOps application needs to be created in a separate step as the CRDs are not created until 
# the Operator is installed and so the plan fails.

#resource "kubernetes_manifest" "gitops_application" {
#  manifest = yamldecode(<<EOT
#apiVersion: argoproj.io/v1alpha1
#kind: Application
#metadata:
#  name: cluster-config
#  namespace: openshift-gitops
#spec:
#  destination:
#    namespace: openshift-operators
#    server: https://kubernetes.default.svc
#  project: default
#  source:
#    directory:
#      jsonnet: {}
#      recurse: truemanifest update resource
#    path: applications
#    repoURL: https://github.com/crscottau/aro-gitops.git
#    targetRevision: HEAD
#  syncPolicy:
#    automated: {}
#    syncOptions:
#      - CreateNamespace=true 
#EOT
#  )
#
# depends_on = [ kubernetes_manifest.gitops_subscription ] 
#
#}